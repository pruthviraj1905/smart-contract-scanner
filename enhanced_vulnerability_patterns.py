#!/usr/bin/env python3
"""
Enhanced Vulnerability Patterns for High-Impact Non-Privileged Fund Drains
Implements CRITICAL priority patterns from vulnerability taxonomy analysis

Priority Implementation:
1. ðŸ”´ CRITICAL: Incorrect Withdrawal/Redemption Accounting (#8)  
2. ðŸ”´ CRITICAL: State Desync / Balance Tracking (#20)
3. ðŸŸ  HIGH: ERC20 Handling Bugs (#12)
4. ðŸŸ  HIGH: Reward/Fee Distribution Logic (#13)
"""

import re
from typing import List, Dict, Tuple
from dataclasses import dataclass

@dataclass
class EnhancedVulnPattern:
    name: str
    category: str
    severity: str
    patterns: List[str]
    decompiled_patterns: List[str]
    description: str
    exploit_path: str
    impact: str
    recommendation: str
    confidence: float

class EnhancedVulnerabilityPatterns:
    def __init__(self):
        self.patterns = self._initialize_critical_patterns()
    
    def _initialize_critical_patterns(self) -> Dict[str, List[EnhancedVulnPattern]]:
        """Initialize critical high-impact vulnerability patterns"""
        
        return {
            # ðŸ”´ CRITICAL #8: Incorrect Withdrawal/Redemption Accounting
            'withdrawal_accounting': [
                EnhancedVulnPattern(
                    name="Withdrawal Math Before Balance Update",
                    category="withdrawal_accounting",
                    severity="CRITICAL",
                    patterns=[
                        # State updated after transfer - classic CEI violation
                        r'\.transfer\s*\([^)]*\)[^;]*;[^}]*(?:balance|amount|shares)\s*[-=]',
                        r'\.call\{value:\s*[^}]*\}[^;]*;[^}]*(?:balance|totalSupply)\s*[-=]',
                        r'payable\([^)]*\)\.transfer\([^)]*\)[^;]*;[^}]*(?:balances|_balances)\[[^\]]*\]\s*[-=]',
                        
                        # Wrong denominator in share calculations
                        r'(?:shares|amount)\s*=\s*[^;]*\/\s*(?:totalSupply|totalShares)(?![^;]*balanceOf)',
                        r'(?:withdraw|redeem)Amount\s*=\s*[^;]*\/\s*(?:currentSupply|supply)(?![^;]*current)',
                        
                        # Stale totalShares/totalSupply usage
                        r'(?:totalShares|totalSupply)(?![^;]*=)[^;]*\/[^;]*(?:withdraw|redeem)',
                        r'(?:shares|amount)\s*\*\s*totalAssets\s*\/\s*totalSupply(?![^;]*\+=)',
                    ],
                    decompiled_patterns=[
                        r'CALL.*value.*SSTORE.*(?:balance|supply)',  # Call before storage update
                        r'SSTORE.*(?:balance|shares).*CALL',         # Storage after call
                        r'DIV.*totalSupply.*(?:balance|shares)',     # Division without current balance
                    ],
                    description="Withdrawal calculations use stale state or update balances in wrong order",
                    exploit_path="1. Call withdraw/redeem function\n2. Calculation uses stale totalShares\n3. Receive more tokens than fair share\n4. Repeat to drain protocol",
                    impact="Attacker can withdraw more than their fair share, potentially draining entire protocol",
                    recommendation="Update internal state before transfers, use current balances in calculations",
                    confidence=0.85
                ),
                
                EnhancedVulnPattern(
                    name="Double-Counting Deposit in Withdrawal",
                    category="withdrawal_accounting", 
                    severity="CRITICAL",
                    patterns=[
                        # User balance counted twice in calculations
                        r'(?:balances|shares)\[[^\]]*\]\s*\+\s*(?:amount|deposit)[^;]*(?:balances|shares)\[[^\]]*\]',
                        r'(?:userBalance|userShares)\s*\+[^;]*(?:amount|value)[^;]*(?:withdraw|redeem)',
                        
                        # Withdrawal without proper subtraction
                        r'function\s+(?:withdraw|redeem)[^{]*\{(?![^}]*(?:balances|shares)\[[^\]]*\]\s*[-=])',
                        r'\.transfer\([^)]*(?:amount|balance)[^)]*\)(?![^;]*(?:balances|_balances)\[[^\]]*\]\s*[-=])',
                    ],
                    decompiled_patterns=[
                        r'ADD.*balance.*ADD.*amount',  # Double addition
                        r'CALL.*value.*(?!SSTORE)',    # Transfer without storage update
                    ],
                    description="User deposits or balances are counted multiple times in withdrawal calculations",
                    exploit_path="1. Deposit tokens to get shares\n2. Call withdrawal function\n3. Deposit counted twice in calculation\n4. Withdraw more than deposited",
                    impact="Direct fund drain - attacker receives more tokens than they should",
                    recommendation="Ensure user balances are decremented properly and not double-counted",
                    confidence=0.9
                ),
                
                EnhancedVulnPattern(
                    name="Share-to-Asset Conversion Error",
                    category="withdrawal_accounting",
                    severity="HIGH", 
                    patterns=[
                        # Incorrect conversion formulas
                        r'(?:assets|tokens)\s*=\s*shares\s*\/\s*(?:totalShares|sharePrice)',  # Should multiply
                        r'(?:shares|amount)\s*=\s*assets\s*\*\s*(?:totalShares|sharePrice)',   # Wrong direction
                        r'(?:previewRedeem|convertToAssets)\s*\([^)]*\)\s*\*',                # Preview multiplied
                        
                        # Missing slippage/rounding protection
                        r'(?:shares|assets)\s*=\s*[^;]*\/[^;]*(?![^;]*(?:mul|div)Div)',
                        r'(?:withdraw|redeem).*amount[^;]*(?![^;]*(?:min|slippage))',
                    ],
                    decompiled_patterns=[
                        r'DIV.*shares.*(?!MUL)',  # Division where should multiply
                        r'MUL.*assets.*shares',   # Wrong operation order
                    ],
                    description="Incorrect mathematical conversion between shares and underlying assets",
                    exploit_path="1. Deposit to get shares\n2. Conversion formula gives wrong exchange rate\n3. Redeem shares for more assets\n4. Repeat arbitrage",
                    impact="Arbitrage opportunity allows gradual drain of protocol funds",
                    recommendation="Use correct share-to-asset conversion formulas with rounding protection",
                    confidence=0.8
                )
            ],
            
            # ðŸ”´ CRITICAL #20: State Desync / Balance Tracking
            'state_desync': [
                EnhancedVulnPattern(
                    name="Internal Balance vs Token Balance Mismatch",
                    category="state_desync",
                    severity="CRITICAL", 
                    patterns=[
                        # Internal tracking without actual balance check
                        r'(?:totalSupply|totalBalance)\s*\+=\s*amount(?![^;]*balanceOf)',
                        r'(?:reserves|liquidity)\s*=\s*[^;]*(?![^;]*\.balanceOf\()',
                        r'(?:_balances|balances)\[[^\]]*\]\s*\+=\s*[^;]*(?![^;]*transferFrom)',
                        
                        # Assumptions about transfer success
                        r'transferFrom\([^)]*\)[^;]*;[^}]*(?:balance|supply)\s*\+=',
                        r'\.transfer\([^)]*\)(?![^;]*require\()',
                        r'\.transferFrom\([^)]*\)(?![^;]*require\(.*success)',
                        
                        # Direct balance manipulation without sync
                        r'(?:balances|_balances)\[[^\]]*\]\s*=\s*[^;]*(?![^;]*sync|update)',
                        r'assembly\s*\{[^}]*sstore[^}]*(?:balance|supply)(?![^}]*balanceOf)',
                    ],
                    decompiled_patterns=[
                        r'SSTORE.*balance.*(?!CALL)',      # Storage update without external call
                        r'CALL.*transferFrom.*SSTORE',     # Assume transfer success
                        r'ADD.*totalSupply.*(?!BALANCE)',  # Add without balance check
                    ],
                    description="Internal accounting becomes out of sync with actual token balances",
                    exploit_path="1. Transfer tokens that fail or have fees\n2. Internal tracking still increases\n3. Withdraw based on inflated internal balance\n4. Drain actual tokens",
                    impact="Complete protocol drain possible when internal accounting exceeds real balances",
                    recommendation="Always check actual token balances, validate transfer success, sync internal state",
                    confidence=0.9
                ),
                
                EnhancedVulnPattern(
                    name="Fee-on-Transfer Token Incompatibility",
                    category="state_desync",
                    severity="HIGH",
                    patterns=[
                        # Assumes transfer amount equals received amount
                        r'transferFrom\([^,]*,\s*[^,]*,\s*(?P<amount>\w+)\)[^;]*;[^}]*(?:balance|supply)\s*\+=\s*(?P=amount)',
                        r'\.transfer\([^,]*,\s*(?P<amount>\w+)\)[^;]*;[^}]*(?:sent|transferred)\s*\+=\s*(?P=amount)',
                        
                        # No balance difference calculation
                        r'transferFrom\([^)]*\)(?![^}]*(?:balanceBefore|balanceAfter))',
                        r'function\s+deposit[^{]*\{(?![^}]*(?:before|after).*balanceOf)',
                        
                        # Direct amount usage without verification
                        r'(?:deposit|stake|mint)\([^)]*amount[^)]*\)[^{]*\{(?![^}]*actualAmount)',
                    ],
                    decompiled_patterns=[
                        r'CALL.*transferFrom.*SSTORE.*(?!SUB.*BALANCE)',  # No balance diff calculation
                        r'ADD.*balance.*(?!BALANCE.*SUB)',                # Add amount without checking actual
                    ],
                    description="Contract assumes transfer amount equals received amount (ignores fees)",
                    exploit_path="1. Use fee-on-transfer token\n2. Transfer 100 tokens, only 98 received\n3. Contract credits 100 internally\n4. Withdraw 100 tokens draining protocol",
                    impact="Gradual fund drain through accumulated fee differences",
                    recommendation="Calculate actual received amount: balanceAfter - balanceBefore",
                    confidence=0.85
                ),
                
                EnhancedVulnPattern(
                    name="Reward Accounting Without Balance Sync",
                    category="state_desync", 
                    severity="HIGH",
                    patterns=[
                        # Reward distribution without checking actual tokens
                        r'(?:rewards|rewardBalance)\s*\+=\s*[^;]*(?![^;]*balanceOf)',
                        r'(?:distribute|mint)Rewards\([^)]*\)(?![^{]*actualBalance)',
                        r'rewardRate\s*\*\s*time(?![^;]*\.balanceOf)',
                        
                        # Claims without validating available rewards
                        r'function\s+claimRewards[^{]*\{(?![^}]*require.*balanceOf)',
                        r'(?:pendingRewards|earned)\([^)]*\)(?![^;]*min\(.*balanceOf)',
                    ],
                    decompiled_patterns=[
                        r'MUL.*rewardRate.*(?!BALANCE)',   # Reward calculation without balance check
                        r'SSTORE.*rewards.*(?!CALL)',     # Store rewards without token check
                    ],
                    description="Reward calculations don't validate against actual available reward tokens",
                    exploit_path="1. Protocol promises more rewards than tokens available\n2. Claim rewards based on calculation\n3. Drain all available reward tokens\n4. Later claimers get nothing",
                    impact="Reward token drain, unfair distribution favoring early claimers",
                    recommendation="Cap rewards by min(calculated, actualBalance), sync on distribution",
                    confidence=0.8
                )
            ],
            
            # ðŸŸ  HIGH #12: ERC20 Handling Bugs  
            'erc20_handling': [
                EnhancedVulnPattern(
                    name="Missing Transfer Return Value Check",
                    category="erc20_handling",
                    severity="HIGH",
                    patterns=[
                        # transfer() without return check
                        r'\.transfer\s*\([^)]*\)\s*;(?![^;]*(?:require|assert|success))',
                        r'\.transferFrom\s*\([^)]*\)\s*;(?![^;]*(?:require|assert|success))',
                        r'IERC20\([^)]*\)\.transfer(?![^;]*(?:require|assert))',
                        
                        # approve() without return check  
                        r'\.approve\s*\([^)]*\)\s*;(?![^;]*(?:require|assert|success))',
                        
                        # Using transfer in require but not checking return value
                        r'require\s*\(\s*[^,]*\.transfer\s*\([^)]*\)\s*\)',
                    ],
                    decompiled_patterns=[
                        r'CALL.*transfer.*POP',           # Call transfer but ignore return value
                        r'CALL.*transferFrom.*JUMPI',     # Call without checking success
                    ],
                    description="ERC20 transfer calls don't check return values for success",
                    exploit_path="1. Use token that returns false on transfer failure\n2. Transfer fails but contract continues\n3. Internal accounting updates despite failed transfer\n4. Withdraw tokens that were never deposited",
                    impact="Accounting becomes out of sync with actual balances, leading to fund drain",
                    recommendation="Always check transfer return values or use SafeERC20",
                    confidence=0.9
                ),
                
                EnhancedVulnPattern(
                    name="Approve Race Condition Vulnerability",
                    category="erc20_handling", 
                    severity="MEDIUM",
                    patterns=[
                        # Direct approve to new value without reset
                        r'\.approve\s*\([^,]*,\s*(?!0\s*\))[^)]*\)(?![^;]*(?:approve.*0|safeApprove))',
                        
                        # increaseAllowance pattern issues
                        r'increaseAllowance\s*\([^)]*\)(?![^;]*(?:current|existing))',
                        
                        # Manual allowance increase
                        r'(?:allowance|_allowances)\[[^\]]*\]\[[^\]]*\]\s*\+=(?![^;]*require)',
                    ],
                    decompiled_patterns=[
                        r'SSTORE.*allowance.*(?!0)',  # Store non-zero allowance directly
                    ],
                    description="ERC20 approval allows front-running to spend old + new allowance",
                    exploit_path="1. User approves 100 tokens\n2. Later wants to change to 50\n3. Spender front-runs and spends 100\n4. Then spends another 50 after approval\n5. Total: 150 tokens stolen",
                    impact="Users can lose more tokens than intended due to approval front-running",
                    recommendation="Reset to 0 first, or use increaseAllowance/decreaseAllowance",
                    confidence=0.7
                ),
                
                EnhancedVulnPattern(
                    name="Token Address Validation Missing", 
                    category="erc20_handling",
                    severity="HIGH",
                    patterns=[
                        # User-controlled token address without validation
                        r'function\s+[^{]*\(\s*[^,]*\s+token[^)]*\)[^{]*\{(?![^}]*require\([^}]*token)',
                        r'IERC20\s*\(\s*[^)]*\s*\)\.(?:transfer|approve)(?![^;]*(?:whitelist|approved))',
                        
                        # Arbitrary token calls
                        r'(?:address|IERC20)\s*\([^)]*\)\.call\s*\([^)]*\)(?![^;]*require)',
                        r'token\.functionCall\s*\([^)]*\)(?![^;]*validate)',
                    ],
                    decompiled_patterns=[
                        r'CALL.*token.*(?!STATICCALL)',  # Call to arbitrary token address
                    ],
                    description="Functions accept arbitrary token addresses without validation",
                    exploit_path="1. Call function with malicious token address\n2. Malicious token executes arbitrary code\n3. Reentrancy or state manipulation\n4. Drain protocol funds",
                    impact="Complete protocol compromise through malicious token contracts",
                    recommendation="Whitelist approved tokens or validate token contracts",
                    confidence=0.85
                )
            ],
            
            # ðŸŸ  HIGH #13: Reward/Fee Distribution Logic
            'reward_distribution': [
                EnhancedVulnPattern(
                    name="Reward Index Manipulation",
                    category="reward_distribution",
                    severity="HIGH", 
                    patterns=[
                        # Reward index updated incorrectly
                        r'rewardIndex\s*\+=\s*[^;]*(?![^;]*(?:totalSupply|totalStaked))',
                        r'(?:rewardPerToken|rewardRate)\s*=\s*[^;]*(?![^;]*(?:duration|timeElapsed))',
                        
                        # User rewards calculated before index update
                        r'(?:userRewards|earned)\s*=\s*[^;]*rewardIndex(?![^}]*updateReward)',
                        r'function\s+(?:claimRewards|harvest)[^{]*\{(?![^}]*(?:update|sync))',
                        
                        # Missing reward checkpoint
                        r'(?:stake|deposit|withdraw)\([^)]*\)(?![^{]*(?:updateReward|checkpoint))',
                    ],
                    decompiled_patterns=[
                        r'SSTORE.*rewardIndex.*(?!DIV.*totalSupply)',  # Index without proper calculation
                        r'MUL.*userBalance.*rewardIndex.*(?!UPDATE)',  # Calculation before update
                    ],
                    description="Reward index calculations can be manipulated to claim excessive rewards",
                    exploit_path="1. Stake small amount when few users\n2. Large rewards accrue to small total\n3. Index increases dramatically\n4. Claim rewards based on inflated index\n5. Withdraw and repeat",
                    impact="Attacker can drain reward pool by manipulating reward calculations",
                    recommendation="Update reward index before all user interactions, validate calculations",
                    confidence=0.8
                ),
                
                EnhancedVulnPattern(
                    name="Claiming Historical Rewards Without Contribution",
                    category="reward_distribution",
                    severity="CRITICAL",
                    patterns=[
                        # New users get historical rewards
                        r'userRewards\s*=\s*(?:balance|shares)\s*\*\s*rewardIndex(?![^;]*(?:join|start)Time)',
                        r'function\s+claimRewards[^{]*\{(?![^}]*(?:since|from).*stake)',
                        
                        # No time-based reward limitation
                        r'(?:rewards|earned)\s*\([^)]*\)(?![^{]*(?:min|max|since))',
                        r'rewardPerToken\s*\*\s*(?:balance|stake)(?![^;]*(?:duration|period))',
                    ],
                    decompiled_patterns=[
                        r'MUL.*balance.*rewardIndex.*(?!SUB.*startTime)',  # No start time consideration
                    ],
                    description="New stakers can claim rewards that accrued before their participation",
                    exploit_path="1. Wait for rewards to accrue to protocol\n2. Stake tokens to get shares\n3. Immediately claim all historical rewards\n4. Withdraw stake\n5. Repeat with new address",
                    impact="Complete reward pool drain by claiming rewards without contribution",
                    recommendation="Track user join time, only reward from participation start",
                    confidence=0.9
                ),
                
                EnhancedVulnPattern(
                    name="Fee Distribution Without Proper Validation",
                    category="reward_distribution", 
                    severity="MEDIUM",
                    patterns=[
                        # Fee percentage not validated
                        r'fee\s*=\s*amount\s*\*\s*(?:feeRate|percentage)(?![^;]*(?:require|assert))',
                        r'function\s+setFee[^{]*\{(?![^}]*require\([^}]*(?:<|<=))',
                        
                        # Fee recipient not validated  
                        r'feeRecipient\s*=\s*[^;]*(?![^;]*require\([^}]*(?:!=\s*address\(0\)|zero))',
                        r'\.transfer\s*\(\s*feeRecipient\s*,(?![^)]*require)',
                    ],
                    decompiled_patterns=[
                        r'MUL.*amount.*feeRate.*(?!GT.*100)',  # Fee calculation without limit check
                    ],
                    description="Fee calculations and distributions lack proper validation",
                    exploit_path="1. Set fee rate to > 100%\n2. Fee calculation overflows or takes more than principal\n3. All user funds go to fees\n4. Drain protocol through excessive fees",
                    impact="Users lose more than intended through uncapped or manipulated fees",
                    recommendation="Validate fee percentages, check recipient addresses, cap fee rates",
                    confidence=0.7
                )
            ]
        }
    
    def get_all_patterns(self) -> List[EnhancedVulnPattern]:
        """Get all enhanced vulnerability patterns"""
        all_patterns = []
        for category_patterns in self.patterns.values():
            all_patterns.extend(category_patterns)
        return all_patterns
    
    def get_patterns_by_category(self, category: str) -> List[EnhancedVulnPattern]:
        """Get patterns for specific category"""
        return self.patterns.get(category, [])
    
    def get_critical_patterns(self) -> List[EnhancedVulnPattern]:
        """Get only critical severity patterns"""
        return [pattern for patterns in self.patterns.values() 
                for pattern in patterns if pattern.severity == "CRITICAL"]
    
    def check_pattern_match(self, pattern: EnhancedVulnPattern, code: str, is_decompiled: bool = False) -> List[Tuple[str, int]]:
        """Check if pattern matches in code and return matches with line numbers"""
        patterns_to_check = pattern.decompiled_patterns if is_decompiled else pattern.patterns
        matches = []
        
        lines = code.split('\n')
        for line_num, line in enumerate(lines, 1):
            for regex_pattern in patterns_to_check:
                if re.search(regex_pattern, line, re.IGNORECASE):
                    matches.append((line.strip(), line_num))
        
        return matches